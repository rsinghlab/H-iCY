import ast
import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
import os
import seaborn as sns
import math
from scipy import stats

import csv
from scipy.stats import ttest_ind
sns.set_context('talk')

def parse_results_from_file(file_path):
    '''
        Works with the file format generated by the evaluate function, which basically dumps all the data
        @params: file_path <string>, path to the results dump file
        @returns: <dict> of parsed out results
    '''

    file_data = open(file_path).read().split('\n')[:-1]

    # filter all the dividing lines
    file_data = list(filter(lambda x: '++++++++++++++++++++++++++++' not in x, file_data))
    
    parsed_results  = {}

    # find all the models and datasets in this file
    for data in file_data:
        data = data.split(':')
        model = data[0]
        dataset = data[1]
        

        results = ast.literal_eval(':'.join(data[2:]))
        

        if dataset not in parsed_results.keys():
            parsed_results[dataset] = {}

        if model not in parsed_results[dataset].keys():
            parsed_results[dataset][model] = {}
        
        for result in results:
            if result not in parsed_results[dataset][model].keys():
                
                parsed_results[dataset][model][result] = np.mean(results[result])

    

    for dataset in parsed_results.keys():
        df = pd.DataFrame(parsed_results[dataset]).T
        output = os.path.join('results','csv', '{}_{}.csv'.format(dataset, file_path.split('/')[-1].split('.')[0]))
        df.to_csv(output)

        
    
    

    return parsed_results



def plot_real_dataset_upscaled_by_synthetic_models_figure(gm12878_results, imr90_results, k562_results):
    k562_condensed_results = {
        # 'SSIM': {
        #     'baseline': 0,
        #     'smoothing': 0,
        #     'hicplus': 0,
        #     'hicnn': 0,
        #     'deephic': 0
        # },
        # 'PCC': {
        #     'baseline': 0,
        #     'smoothing': 0,
        #     'hicplus': 0,
        #     'hicnn': 0,
        #     'deephic': 0
        # },
        # 'SCC': {
        #     'baseline': 0,
        #     'smoothing': 0,
        #     'hicplus': 0,
        #     'hicnn': 0,
        #     'deephic': 0
        # },
        'genomedisco': {
            'baseline': 0,
            'smoothing': 0,
            'hicplus': 0,
            'hicnn': 0,
            'deephic': 0,
            'vehicle': 0,
        },
        'hicrep': {
            'baseline': 0,
            'smoothing': 0,
            'hicplus': 0,
            'hicnn': 0,
            'deephic': 0,
            'vehicle': 0,
        },
        'quasar-rep': {
            'baseline': 0,
            'smoothing': 0,
            'hicplus': 0,
            'hicnn': 0,
            'deephic': 0,
            'vehicle': 0,
        },
        'hic-spector': {
            'baseline': 0,
            'smoothing': 0,
            'hicplus': 0,
            'hicnn': 0,
            'deephic': 0,
            'vehicle': 0,
        }

    }
    for dataset in k562_results.keys():
        k562_dataset_results = k562_results[dataset]

        for method in k562_condensed_results.keys():            
            for model in k562_condensed_results[method].keys():
                similar_models = list(filter(lambda x: model in x, k562_dataset_results.keys()))
                best_method_result = k562_dataset_results[similar_models[0]][method]
                for similar_model in similar_models:
                    try:
                        if k562_dataset_results[similar_model][method] >= best_method_result:
                            best_method_result = k562_dataset_results[similar_model][method]
                    except KeyError:
                        print(similar_model, method)
                    
                k562_condensed_results[method][model] = best_method_result

    df = pd.DataFrame(k562_condensed_results)
    df = df.T
    print(df)
    fig, ax = plt.subplots(figsize=(18, 5))
    x = np.arange(4)
    bar_width = 0.11

    b1 = ax.bar(x, df['baseline'],
            width=bar_width, label='Baseline')

    b2 = ax.bar(x+bar_width, df['smoothing'],
            width=bar_width, label='Smoothing')
    
    b3 = ax.bar(x+(2*bar_width), df['hicplus'],
            width=bar_width, label='HiCPlus')

    b4 = ax.bar(x+(3*bar_width), df['hicnn'],
            width=bar_width, label='HiCNN')
    
    b5 = ax.bar(x+(4*bar_width), df['deephic'],
            width=bar_width, label='DeepHiC')
    
    b6 = ax.bar(x+(5*bar_width), df['vehicle'],
            width=bar_width, label='VeHiCle')

    ax.set_xticks(x + bar_width*2.1)
    ax.set_xticklabels(['GenomeDISCO', 'HiCRep', 'QuASAR-Rep', 'HiCSpector'])
    
    #ax.legend()
    ax.spines['top'].set_visible(False)
    ax.spines['right'].set_visible(False)
    ax.spines['left'].set_visible(False)
    ax.spines['bottom'].set_color('#DDDDDD')
    ax.tick_params(bottom=False, left=False)
    ax.set_axisbelow(True)
    ax.yaxis.grid(True, color='#EEEEEE')
    ax.xaxis.grid(False)
    ax.set_ylim([0, 1])
    #ax.set_xlabel('Metrics', labelpad=15)
    ax.set_ylabel('Score', labelpad=15)
    
    fig.tight_layout()
    # For each bar in the chart, add a text label.
    for bar in ax.patches:
        # The text annotation for each bar should be its height.
        bar_value = round(bar.get_height(), 3)

        # Format the text with commas to separate thousands. You can do
        # any type of formatting here though.
        text = f'{bar_value:,}'
        # This will give the middle of each bar on the x-axis.
        text_x = bar.get_x() + bar.get_width() / 2
        # get_y() is where the bar starts so we add the height to it.
        text_y = bar.get_y() + bar_value
        # If we want the text to be the same color as the bar, we can
        # get the color like so:
        bar_color = bar.get_facecolor()
        # If you want a consistent color, you can just set it as a constant, e.g. #222222
        # ax.text(text_x, text_y, text, ha='center', va='bottom',
        #         size=14)

    plt.savefig('plots/k562_synthetic-model_upscale_real-data.png')
    
    imr90_condensed_results = {
        # 'SSIM': {
        #     'baseline': 0,
        #     'smoothing': 0,
        #     'hicplus': 0,
        #     'hicnn': 0,
        #     'deephic': 0
        # },
        # 'PCC': {
        #     'baseline': 0,
        #     'smoothing': 0,
        #     'hicplus': 0,
        #     'hicnn': 0,
        #     'deephic': 0
        # },
        # 'SCC': {
        #     'baseline': 0,
        #     'smoothing': 0,
        #     'hicplus': 0,
        #     'hicnn': 0,
        #     'deephic': 0
        # },
        'genomedisco': {
            'baseline': 0,
            'smoothing': 0,
            'hicplus': 0,
            'hicnn': 0,
            'deephic': 0,
            'vehicle': 0,
        },
        'hicrep': {
            'baseline': 0,
            'smoothing': 0,
            'hicplus': 0,
            'hicnn': 0,
            'deephic': 0,
            'vehicle': 0,
        },
        'quasar-rep': {
            'baseline': 0,
            'smoothing': 0,
            'hicplus': 0,
            'hicnn': 0,
            'deephic': 0,
            'vehicle': 0,
        },
        'hic-spector': {
            'baseline': 0,
            'smoothing': 0,
            'hicplus': 0,
            'hicnn': 0,
            'deephic': 0,
            'vehicle': 0,
        }

    }


    for dataset in imr90_results.keys():
        imr90_dataset_results = imr90_results[dataset]

        for method in imr90_condensed_results.keys():
            for model in imr90_condensed_results[method].keys():
                
                similar_models = list(filter(lambda x: model in x,imr90_dataset_results.keys()))
                
                best_method_result = imr90_dataset_results[similar_models[0]][method]
                for similar_model in similar_models:
                    if imr90_dataset_results[similar_model][method] >= best_method_result:
                        best_method_result = imr90_dataset_results[similar_model][method]
                
                imr90_condensed_results[method][model] = best_method_result

    df = pd.DataFrame(imr90_condensed_results)
    df = df.T

    fig, ax = plt.subplots(figsize=(18, 5))
    x = np.arange(4)
    bar_width = 0.11

    b1 = ax.bar(x, df['baseline'],
            width=bar_width, label='Baseline')

    b2 = ax.bar(x+bar_width, df['smoothing'],
            width=bar_width, label='Smoothing')
    
    b3 = ax.bar(x+(2*bar_width), df['hicplus'],
            width=bar_width, label='HiCPlus')

    b4 = ax.bar(x+(3*bar_width), df['hicnn'],
            width=bar_width, label='HiCNN')
    
    b5 = ax.bar(x+(4*bar_width), df['deephic'],
            width=bar_width, label='DeepHiC')
    
    b6 = ax.bar(x+(5*bar_width), df['vehicle'],
            width=bar_width, label='VeHiCle')

    ax.set_xticks(x + bar_width*2.1)
    ax.set_xticklabels(['GenomeDISCO', 'HiCRep', 'QuASAR-Rep', 'HiCSpector'])
    
    #ax.legend()
    ax.spines['top'].set_visible(False)
    ax.spines['right'].set_visible(False)
    ax.spines['left'].set_visible(False)
    ax.spines['bottom'].set_color('#DDDDDD')
    ax.tick_params(bottom=False, left=False)
    ax.set_axisbelow(True)
    ax.yaxis.grid(True, color='#EEEEEE')
    ax.xaxis.grid(False)
    ax.set_ylim([0, 1])
    #ax.set_xlabel('Metrics', labelpad=15)
    ax.set_ylabel('Score', labelpad=15)
    
    fig.tight_layout()
    # For each bar in the chart, add a text label.
    for bar in ax.patches:
        # The text annotation for each bar should be its height.
        bar_value = round(bar.get_height(), 3)

        # Format the text with commas to separate thousands. You can do
        # any type of formatting here though.
        text = f'{bar_value:,}'
        # This will give the middle of each bar on the x-axis.
        text_x = bar.get_x() + bar.get_width() / 2
        # get_y() is where the bar starts so we add the height to it.
        text_y = bar.get_y() + bar_value
        # If we want the text to be the same color as the bar, we can
        # get the color like so:
        bar_color = bar.get_facecolor()
        # If you want a consistent color, you can just set it as a constant, e.g. #222222
        # ax.text(text_x, text_y, text, ha='center', va='bottom',
        #         size=14)

    plt.savefig('plots/imr90_synthetic-model_upscale_real-data.png')

    for dataset in gm12878_results.keys():
        gm12878_condensed_results = {
            # 'SSIM': {
            #     'baseline': 0,
            #     'smoothing': 0,
            #     'hicplus': 0,
            #     'hicnn': 0,
            #     'deephic': 0
            # },
            # 'PCC': {
            #     'baseline': 0,
            #     'smoothing': 0,
            #     'hicplus': 0,
            #     'hicnn': 0,
            #     'deephic': 0
            # },
            # 'SCC': {
            #     'baseline': 0,
            #     'smoothing': 0,
            #     'hicplus': 0,
            #     'hicnn': 0,
            #     'deephic': 0
            # },
            'genomedisco': {
                'baseline': 0,
                'smoothing': 0,
                'hicplus': 0,
                'hicnn': 0,
                'deephic': 0,
                'vehicle': 0,
            },
            'hicrep': {
                'baseline': 0,
                'smoothing': 0,
                'hicplus': 0,
                'hicnn': 0,
                'deephic': 0,
                'vehicle': 0,
            },
            'quasar-rep': {
                'baseline': 0,
                'smoothing': 0,
                'hicplus': 0,
                'hicnn': 0,
                'deephic': 0,
                'vehicle': 0,
            },
            'hic-spector': {
                'baseline': 0,
                'smoothing': 0,
                'hicplus': 0,
                'hicnn': 0,
                'deephic': 0,
                'vehicle': 0,
            }

        }
        gm12878_dataset_results = gm12878_results[dataset]

        for method in gm12878_condensed_results.keys():
            for model in gm12878_condensed_results[method].keys():
                
                similar_models = list(filter(lambda x: model in x,gm12878_dataset_results.keys()))
                
                best_method_result = gm12878_dataset_results[similar_models[0]][method]
                for similar_model in similar_models:
                    if gm12878_dataset_results[similar_model][method] >= best_method_result:
                        best_method_result = gm12878_dataset_results[similar_model][method]
                
                gm12878_condensed_results[method][model] = best_method_result

        df = pd.DataFrame(gm12878_condensed_results)
        df = df.T

        fig, ax = plt.subplots(figsize=(18, 5))
        x = np.arange(4)
        bar_width = 0.11

        b1 = ax.bar(x, df['baseline'],
                width=bar_width, label='Baseline')

        b2 = ax.bar(x+bar_width, df['smoothing'],
                width=bar_width, label='Smoothing')
        
        b3 = ax.bar(x+(2*bar_width), df['hicplus'],
                width=bar_width, label='HiCPlus')

        b4 = ax.bar(x+(3*bar_width), df['hicnn'],
                width=bar_width, label='HiCNN')
        
        b5 = ax.bar(x+(4*bar_width), df['deephic'],
                width=bar_width, label='DeepHiC')
        
        b6 = ax.bar(x+(5*bar_width), df['vehicle'],
                width=bar_width, label='VeHiCle')

        ax.set_xticks(x + bar_width*2.1)
        ax.set_xticklabels(['GenomeDISCO', 'HiCRep', 'QuASAR-Rep', 'HiCSpector'])
        if dataset == 'encode0':
            ax.legend()
        ax.spines['top'].set_visible(False)
        ax.spines['right'].set_visible(False)
        ax.spines['left'].set_visible(False)
        ax.spines['bottom'].set_color('#DDDDDD')
        ax.tick_params(bottom=False, left=False)
        ax.set_axisbelow(True)
        ax.yaxis.grid(True, color='#EEEEEE')
        ax.xaxis.grid(False)
        ax.set_ylim([0, 1])
        #ax.set_xlabel('Metrics', labelpad=15)
        ax.set_ylabel('Score', labelpad=15)
        
        fig.tight_layout()
        # For each bar in the chart, add a text label.
        for bar in ax.patches:
            # The text annotation for each bar should be its height.
            bar_value = round(bar.get_height(), 3)

            # Format the text with commas to separate thousands. You can do
            # any type of formatting here though.
            text = f'{bar_value:,}'
            # This will give the middle of each bar on the x-axis.
            text_x = bar.get_x() + bar.get_width() / 2
            # get_y() is where the bar starts so we add the height to it.
            text_y = bar.get_y() + bar_value
            # If we want the text to be the same color as the bar, we can
            # get the color like so:
            bar_color = bar.get_facecolor()
            # If you want a consistent color, you can just set it as a constant, e.g. #222222
            # ax.text(text_x, text_y, text, ha='center', va='bottom',
            #         size=14)

        plt.savefig('plots/gm12878_{}_synthetic-model_upscale_real-data.png'.format(dataset))










def plot_real_dataset_upscaled_by_real_models_figure(gm12878_results, imr90_results, k562_results):
    for dataset in gm12878_results.keys():
        gm12878_condensed_results = {
            # 'SSIM': {
            #     'hicnn': 0,
            #     'encode': 0,
            #     'ensemble': 0,
            # },
            # 'PCC': {
            #     'hicnn': 0,
            #     'encode': 0,
            #     'ensemble': 0,
            # },
            # 'SCC': {
            #     'hicnn': 0,
            #     'encode': 0,
            #     'ensemble': 0,
            # },
            'genomedisco': {
                'hicnn': 0,
                'encode': 0,
                'ensemble': 0,
            },
            'hicrep': {
                'hicnn': 0,
                'encode': 0,
                'ensemble': 0,
            },
            'quasar-rep': {
                'hicnn': 0,
                'encode': 0,
                'ensemble': 0,
            },
            'hic-spector': {
                'hicnn': 0,
                'encode': 0,
                'ensemble': 0,
            }

        }
        gm12878_dataset_results = gm12878_results[dataset]

        for method in gm12878_condensed_results.keys():
            for model in gm12878_condensed_results[method].keys():
                
                similar_models = list(filter(lambda x: model in x,gm12878_dataset_results.keys()))
                if model == 'hicnn':
                    similar_models.remove('hicnn-encode0')
                    similar_models.remove('hicnn-ensemble')
                    
                print(similar_models)
                
                best_method_result = gm12878_dataset_results[similar_models[0]][method]
                for similar_model in similar_models:
                    if gm12878_dataset_results[similar_model][method] >= best_method_result:
                        best_method_result = gm12878_dataset_results[similar_model][method]
                
                gm12878_condensed_results[method][model] = best_method_result

        df = pd.DataFrame(gm12878_condensed_results)
        df = df.T
        
        fig, ax = plt.subplots(figsize=(18, 5))
        x = np.arange(4)
        bar_width = 0.25
        #print(df['baseline'])

        b1 = ax.bar(x, df['hicnn'],
                width=bar_width, label='HiCNN-Synthetic')

        b2 = ax.bar(x+bar_width, df['encode'],
                width=bar_width, label='HiCNN-LRC-1')
        
        b3 = ax.bar(x+(2*bar_width), df['ensemble'],
                width=bar_width, label='HiCNN-Ensemble')


        ax.set_xticks(x + bar_width)
        ax.set_xticklabels(['GenomeDISCO', 'HiCRep', 'QuASAR-Rep', 'HiCSpector'])
        
        if dataset == 'encode0':
            ax.legend()
        
        ax.spines['top'].set_visible(False)
        ax.spines['right'].set_visible(False)
        ax.spines['left'].set_visible(False)
        ax.spines['bottom'].set_color('#DDDDDD')
        ax.tick_params(bottom=False, left=False)
        ax.set_axisbelow(True)
        ax.yaxis.grid(True, color='#EEEEEE')
        ax.xaxis.grid(False)
        ax.set_ylim([0, 1])
        #ax.set_xlabel('Metrics', labelpad=15)
        ax.set_ylabel('Score', labelpad=15)
        
        fig.tight_layout()
        # For each bar in the chart, add a text label.
        for bar in ax.patches:
            # The text annotation for each bar should be its height.
            bar_value = round(bar.get_height(), 3)

            # Format the text with commas to separate thousands. You can do
            # any type of formatting here though.
            text = f'{bar_value:,}'
            # This will give the middle of each bar on the x-axis.
            text_x = bar.get_x() + bar.get_width() / 2
            # get_y() is where the bar starts so we add the height to it.
            text_y = bar.get_y() + bar_value
            # If we want the text to be the same color as the bar, we can
            # get the color like so:
            bar_color = bar.get_facecolor()
            # If you want a consistent color, you can just set it as a constant, e.g. #222222
            #ax.text(text_x, text_y, text, ha='center', va='bottom',
            #        size=14)

        plt.savefig('plots/gm12878_{}_real-model_upscale_real-data.png'.format(dataset))
    
    
    for dataset in imr90_results.keys():
        imr90_condensed_results = {
            # 'SSIM': {
            #     'hicnn': 0,
            #     'encode': 0,
            #     'ensemble': 0,
            # },
            # 'PCC': {
            #     'hicnn': 0,
            #     'encode': 0,
            #     'ensemble': 0,
            # },
            # 'SCC': {
            #     'hicnn': 0,
            #     'encode': 0,
            #     'ensemble': 0,
            # },
            'genomedisco': {
                'hicnn': 0,
                'encode': 0,
                'ensemble': 0,
            },
            'hicrep': {
                'hicnn': 0,
                'encode': 0,
                'ensemble': 0,
            },
            'quasar-rep': {
                'hicnn': 0,
                'encode': 0,
                'ensemble': 0,
            },
            'hic-spector': {
                'hicnn': 0,
                'encode': 0,
                'ensemble': 0,
            }

        }
        imr90_dataset_results = imr90_results[dataset]

        for method in imr90_condensed_results.keys():
            for model in imr90_condensed_results[method].keys():
                
                similar_models = list(filter(lambda x: model in x,imr90_dataset_results.keys()))
                if model == 'hicnn':
                    similar_models.remove('hicnn-encode0')
                    similar_models.remove('hicnn-ensemble')
                    
                print(similar_models)
                
                best_method_result = imr90_dataset_results[similar_models[0]][method]
                for similar_model in similar_models:
                    print(imr90_dataset_results[similar_model].keys())

                    if imr90_dataset_results[similar_model][method] >= best_method_result:
                        best_method_result = imr90_dataset_results[similar_model][method]
                
                imr90_condensed_results[method][model] = best_method_result

        df = pd.DataFrame(imr90_condensed_results)
        df = df.T
        
        fig, ax = plt.subplots(figsize=(18, 5))
        x = np.arange(4)
        bar_width = 0.25
        #print(df['baseline'])

        b1 = ax.bar(x, df['hicnn'],
                width=bar_width, label='HiCNN-Synthetic')

        b2 = ax.bar(x+bar_width, df['encode'],
                width=bar_width, label='HiCNN-LRC-1')
        
        b3 = ax.bar(x+(2*bar_width), df['ensemble'],
                width=bar_width, label='HiCNN-Ensemble')


        ax.set_xticks(x + bar_width)
        ax.set_xticklabels(['GenomeDISCO', 'HiCRep', 'QuASAR-Rep', 'HiCSpector'])
        
        if dataset == 'encode0':
            ax.legend()
        
        ax.spines['top'].set_visible(False)
        ax.spines['right'].set_visible(False)
        ax.spines['left'].set_visible(False)
        ax.spines['bottom'].set_color('#DDDDDD')
        ax.tick_params(bottom=False, left=False)
        ax.set_axisbelow(True)
        ax.yaxis.grid(True, color='#EEEEEE')
        ax.xaxis.grid(False)
        ax.set_ylim([0, 1])
        #ax.set_xlabel('Metrics', labelpad=15)
        ax.set_ylabel('Score', labelpad=15)
        
        fig.tight_layout()
        # For each bar in the chart, add a text label.
        for bar in ax.patches:
            # The text annotation for each bar should be its height.
            bar_value = round(bar.get_height(), 3)

            # Format the text with commas to separate thousands. You can do
            # any type of formatting here though.
            text = f'{bar_value:,}'
            # This will give the middle of each bar on the x-axis.
            text_x = bar.get_x() + bar.get_width() / 2
            # get_y() is where the bar starts so we add the height to it.
            text_y = bar.get_y() + bar_value
            # If we want the text to be the same color as the bar, we can
            # get the color like so:
            bar_color = bar.get_facecolor()
            # If you want a consistent color, you can just set it as a constant, e.g. #222222
            #ax.text(text_x, text_y, text, ha='center', va='bottom',
            #        size=14)

        plt.savefig('plots/imr90_{}_real-model_upscale_real-data.png'.format(dataset))
    
    for dataset in k562_results.keys():
        k562_condensed_results = {
            # 'SSIM': {
            #     'hicnn': 0,
            #     'encode': 0,
            #     'ensemble': 0,
            # },
            # 'PCC': {
            #     'hicnn': 0,
            #     'encode': 0,
            #     'ensemble': 0,
            # },
            # 'SCC': {
            #     'hicnn': 0,
            #     'encode': 0,
            #     'ensemble': 0,
            # },
            'genomedisco': {
                'hicnn': 0,
                'encode': 0,
                'ensemble': 0,
            },
            'hicrep': {
                'hicnn': 0,
                'encode': 0,
                'ensemble': 0,
            },
            'quasar-rep': {
                'hicnn': 0,
                'encode': 0,
                'ensemble': 0,
            },
            'hic-spector': {
                'hicnn': 0,
                'encode': 0,
                'ensemble': 0,
            }

        }
        k562_dataset_results = k562_results[dataset]

        for method in k562_condensed_results.keys():
            for model in k562_condensed_results[method].keys():
                
                similar_models = list(filter(lambda x: model in x, k562_dataset_results.keys()))
                if model == 'hicnn':
                    similar_models.remove('hicnn-encode0')
                    similar_models.remove('hicnn-ensemble')
                    
                print(similar_models)
                
                best_method_result = k562_dataset_results[similar_models[0]][method]
                for similar_model in similar_models:
                    if k562_dataset_results[similar_model][method] >= best_method_result:
                        best_method_result = k562_dataset_results[similar_model][method]
                
                k562_condensed_results[method][model] = best_method_result

        df = pd.DataFrame(k562_condensed_results)
        df = df.T
        
        fig, ax = plt.subplots(figsize=(18, 5))
        x = np.arange(4)
        bar_width = 0.25
        #print(df['baseline'])

        b1 = ax.bar(x, df['hicnn'],
                width=bar_width, label='HiCNN-Synthetic')

        b2 = ax.bar(x+bar_width, df['encode'],
                width=bar_width, label='HiCNN-LRC-1')
        
        b3 = ax.bar(x+(2*bar_width), df['ensemble'],
                width=bar_width, label='HiCNN-Ensemble')


        ax.set_xticks(x + bar_width)
        ax.set_xticklabels(['GenomeDISCO', 'HiCRep', 'QuASAR-Rep', 'HiCSpector'])
        
        if dataset == 'encode0':
            ax.legend()
        
        ax.spines['top'].set_visible(False)
        ax.spines['right'].set_visible(False)
        ax.spines['left'].set_visible(False)
        ax.spines['bottom'].set_color('#DDDDDD')
        ax.tick_params(bottom=False, left=False)
        ax.set_axisbelow(True)
        ax.yaxis.grid(True, color='#EEEEEE')
        ax.xaxis.grid(False)
        ax.set_ylim([0, 1])
        #ax.set_xlabel('Metrics', labelpad=15)
        ax.set_ylabel('Score', labelpad=15)
        
        fig.tight_layout()
        # For each bar in the chart, add a text label.
        for bar in ax.patches:
            # The text annotation for each bar should be its height.
            bar_value = round(bar.get_height(), 3)

            # Format the text with commas to separate thousands. You can do
            # any type of formatting here though.
            text = f'{bar_value:,}'
            # This will give the middle of each bar on the x-axis.
            text_x = bar.get_x() + bar.get_width() / 2
            # get_y() is where the bar starts so we add the height to it.
            text_y = bar.get_y() + bar_value
            # If we want the text to be the same color as the bar, we can
            # get the color like so:
            bar_color = bar.get_facecolor()
            # If you want a consistent color, you can just set it as a constant, e.g. #222222
            #ax.text(text_x, text_y, text, ha='center', va='bottom',
            #        size=14)

        plt.savefig('plots/k562_{}_real-model_upscale_real-data.png'.format(dataset))







def create_distribution_comparison_plot(data, scatter_points_count, cell_line):    
    from matplotlib.ticker import StrMethodFormatter

    scatter_points_data = {} 
    line_data = {}
    for key in data.keys():
        scatter_points_data[key] = data[key][:scatter_points_count]
        line_data[key] = data[key][scatter_points_count:]
        for key in line_data.keys():
            print(key)
            if key == 'read_count_ratio':
                continue
            m, b = np.polyfit(line_data['read_count_ratio'], line_data[key], 1)
            #print(np.array(line_data['read_count_ratio']) * m)
            plt.plot(np.array(line_data['read_count_ratio']), m*np.array(line_data['read_count_ratio']) + b, c='black')
            plt.scatter(np.array(line_data['read_count_ratio']), np.array(line_data[key]), c='#882255', s=300)
            plt.scatter(np.array(scatter_points_data['read_count_ratio']), np.array(scatter_points_data[key]),
                c='#117733', marker=',', s=300)
            plt.xlabel('Read Count Ratio', size=16)
            plt.xticks(fontsize=16)
            #plt.ylabel(key, size=16)
            plt.yticks(fontsize=16)
            plt.gca().yaxis.set_major_formatter(StrMethodFormatter('{x:,.2f}')) # 2 decimal places
            fig = plt.gcf()
            fig.set_size_inches(6,6)
            fig.savefig('results/{}_{}_distribution_analysis.png'.format(key, cell_line), dpi=100)
            plt.cla()
            plt.clf()



def create_toe_to_toe_comparison_bar_chart(data, metric, output_path):
    labels = [
        ' ',
        '  ',
        '   '
    ]
    colors = [
        '#D81B60',
        '#1E88E5',
        '#FFC107'
    ]  
    data_averages = []
    for x in data:
        data_averages.append(np.mean(x))

    print(data[0], data[1], data[2])

    print(ttest_ind(data[0], data[1]), ((data_averages[0] - data_averages[1])/data_averages[0])*100)
    print(ttest_ind(data[1], data[2]), ((data_averages[2] - data_averages[1])/data_averages[1])*100)



    ymin = round(max([0, (round(min(data_averages), 1)-0.2)]), 1)
    ymax = round(min([1.0, (round(max(data_averages), 1)+0.1)]), 1)

    print(ymin, ymax)

    plt.bar(labels, data_averages, color=colors)
    plt.xticks([])
    plt.ylabel(metric, fontsize=18)
    plt.ylim(ymin, ymax)

    fig = plt.gcf()
    fig.tight_layout()
    fig.set_size_inches(6,6)
    fig.savefig(output_path)
    plt.cla()
    plt.clf()

def parse_result_string(string):
    print(string)

    method = string.split(':')[0]
    dataset = string.split(':')[1]
    results = ast.literal_eval(':'.join(string.split(':')[2:]))


    return method, dataset, results

def condense_results(result_strings):
    results = {}

    # Correlation Analysis results: Returns a table
    for result in result_strings:
        method, dataset, metrics = parse_result_string(result)
        
        if dataset not in results.keys():
            results[dataset] = {}
        
        if method not in results[dataset].keys():
            results[dataset][method] = {}
        
        for metric in metrics.keys():
            results[dataset][method][metric] = np.mean(metrics[metric])
    
    for dataset in results.keys():
        results[dataset] = pd.DataFrame(results[dataset]).T
    
    return results

def condense_sig_inter_results(result_strings):
    results = {}
    for result in result_strings:
        method, dataset, metrics = parse_result_string(result)
        if dataset not in results.keys():
            results[dataset] = {}
        
        for stat in metrics.keys():
            if stat not in results[dataset].keys():
                results[dataset][stat] = {}
            
            if 'x-values' not in results[dataset][stat].keys():
                results[dataset][stat]['x-values'] = list(metrics[stat].keys())
            
            for cutoff in metrics[stat].keys():

                if method not in results[dataset][stat].keys():
                    results[dataset][stat][method] = []
                
                results[dataset][stat][method].append(np.mean(metrics[stat][cutoff]))

    return results
    
            
def condense_sig_inter_results(result_strings):
    results = {}
    for result in result_strings:
        method, dataset, metrics = parse_result_string(result)
        if dataset not in results.keys():
            results[dataset] = {}
        
        for stat in metrics.keys():
            if stat not in results[dataset].keys():
                results[dataset][stat] = {}
            
            if 'x-values' not in results[dataset][stat].keys():
                results[dataset][stat]['x-values'] = list(metrics[stat].keys())
            
            for cutoff in metrics[stat].keys():

                if method not in results[dataset][stat].keys():
                    results[dataset][stat][method] = []
                
                results[dataset][stat][method].append(np.mean(metrics[stat][cutoff]))

    return results
  



def results_file_parser(results_file_path):
    # Read results file 
    results = open(results_file_path).read().split('\n')
    # Filter out stakeholder lines
    results = list(filter(lambda x: '++++++++++++++++++++++++++++' not in x, results))
    results = list(filter(lambda x: x != '', results))

    correlation_result_strings = list(filter(lambda x: 'MSE' in x, results))
    bio_analysis_result_string = list(filter(lambda x: 'hicrep' in x or 'genomedisco' in x, results))
    reconstruction_result_string = list(filter(lambda x: '3d_reconstruction_tmscore' in x, results))
    sig_inter_result_string = list(filter(lambda x: 'p-values' in x, results))
    insulation_score_result_string = list(filter(lambda x: 'insulation_score' in x, results))

    
    correlation_results = condense_results(correlation_result_strings)
    bio_analysis_result = condense_results(bio_analysis_result_string)
    reconstruction_result = condense_results(reconstruction_result_string)
    insulation_results = condense_results(insulation_score_result_string)

    #sig_inter_results = condense_sig_inter_results(sig_inter_result_string)

    
    return correlation_results, bio_analysis_result, reconstruction_result, insulation_results







def create_p_value_graph(dataset_results):

    for dataset in dataset_results.keys():
        # only for p-value
        all_lines = dataset_results[dataset]['p-values']
        plt.figure(figsize=(12, 8), dpi=80)

        x_values = list(map(lambda x: str(x), all_lines['x-values']))
        try:
            smoothing = list(map(lambda x: float(x), all_lines['gaussian-smoothing']))
            plt.plot(x_values, smoothing, color='#E69F00', linewidth=4.0, marker="o", markersize=20)
        except:
            pass
        
        try:
            hicplus = list(map(lambda x: float(x), all_lines['hicplus50']))
            plt.plot(x_values, hicplus, color='#56B4E9', linewidth=4.0, marker='s', markersize=20)
        except:
            pass
        
        
        try:
            hicnn = list(map(lambda x: float(x), all_lines['hicnn100']))
            plt.plot(x_values, hicnn, color='#009E73', linewidth=4.0, marker='*', markersize=20)
        except:
            pass

        try:
            deephic = list(map(lambda x: float(x), all_lines['deephic100']))
            plt.plot(x_values, deephic, color='#F0E442', linewidth=4.0, marker='^', markersize=20)
        except:
            pass

        try:
            vehicle = list(map(lambda x: float(x), all_lines['vehicle']))
            plt.plot(x_values, vehicle, color='#0072B2', linewidth=4.0, marker='d', markersize=20)
        except:
            pass

        try:
            hicnn_encode = list(map(lambda x: float(x), all_lines['hicnn-encode0']))
            plt.plot(x_values, hicnn_encode, color='#D55E00', linewidth=4.0, marker='X', markersize=20)
        except:
            pass
        
        
        


        plt.xlabel('p-value_cutoff', size=30)
        plt.xticks(fontsize= 25)
        plt.ylabel('Jaccard Index', size=30)
        plt.yticks(fontsize= 25)
        plt.yscale('log')
        plt.tight_layout()

        plt.savefig('results/figures/p-value-cutoff_analysis_{}.png'.format(dataset))
        plt.cla()
        plt.clf()
        plt.close()






def create_line_graph_downsampled_datasets_comparison(datasets, output_name, metric):
    lines = {
        'gaussian-smoothing': [],
        'hicplus': [],
        'hicnn': [],
        'hicnn2':[],
        'deephic': [],
        'vehicle': []
    }
    x_values = []

    print(datasets.keys())


    for dataset in datasets.keys():
        if dataset == 'synthetic8':
            continue
        

        dataset_ratio = dataset.split('synthetic')[1]
        x_values.append(dataset_ratio)
        dataset_results = datasets[dataset]
        print(dataset_results)

        for key in lines.keys():
            if key in ['hicnn', 'hicnn2', 'hicplus', 'deephic']:
                model = key+'-'+dataset_ratio
            else:
                model = key
            
            lines[key].append(dataset_results[metric][model])


            #lines[key].append(dataset_results[model, 'genomedisco'])
    
    print(lines, x_values)

    for line in lines.keys(): 
        if line == 'gaussian-smoothing':
            plt.plot(x_values, lines[line], color='#E69F00', linewidth=4.0, marker="o", markersize=20)
        
        if line == 'hicplus':
            plt.plot(x_values, lines[line], color='#56B4E9', linewidth=4.0, marker='s', markersize=20)
        
        if line == 'hicnn':
            plt.plot(x_values, lines[line], color='#009E73', linewidth=4.0, marker='*', markersize=20)
        
        if line == 'hicnn2':
            plt.plot(x_values, lines[line], color='#FF9070', linewidth=4.0, marker='p', markersize=20)
        
        if line == 'deephic':
            plt.plot(x_values, lines[line], color='#F0E442', linewidth=4.0, marker='^', markersize=20)
        
        if line == 'vehicle':
            plt.plot(x_values, lines[line], color='#0072B2', linewidth=4.0, marker='d', markersize=20)
        
        
    plt.xlabel('Downsampling Ratio', size=30)
    plt.xticks(fontsize= 25)
    if metric == 'genomedisco':
        plt.ylabel('GenomeDISCO', size=30)
    else:
        plt.ylabel(metric, size=30)
    
    plt.yticks(fontsize= 25)
    #plt.yscale('log')
    plt.tight_layout()

    plt.savefig('results/figures/{}_{}'.format(metric, output_name))
    plt.cla()
    plt.clf()
    plt.close()











def create_line_graph_real_world_datasets_downsampled_models(input_path):
    reader = csv.reader(open(input_path, 'r'))
    data = {}
    x_values = []
    for idx, row in enumerate(reader):
        if idx == 0:
            row = list(filter(lambda x: x!= '', row))
            x_values = row
        else:
            method = row[0]
            data[method] = list(map(lambda x: float(x), row[1:]))

    
    print(data['HiCPlus'], data['HiCNN'])

    plt.plot(x_values,  data['Smoothing'], color='#E69F00', label='Smoothing', linewidth=4.0, marker="o", markersize=20)
    plt.plot(x_values,  data['HiCPlus'], color='#56B4E9', label='HiCPlus', linewidth=4.0, marker='s', markersize=20)
    plt.plot(x_values,  data['HiCNN'], color='#009E73', label='HiCNN', linewidth=4.0, marker='*', markersize=20)
    plt.plot(x_values,  data['HiCNN2'], color='#FF9070', label='HiCNN2', linewidth=4.0, marker='p', markersize=20)
    plt.plot(x_values,  data['DeepHiC'], color='#F0E442', label='DeeHiC', linewidth=4.0, marker='^', markersize=20)
    plt.plot(x_values,  data['VeHiCLe'], color='#0072B2', label = 'VeHiCle', linewidth=4.0, marker='d', markersize=20)

    fig = plt.gcf()
    fig.tight_layout()
    fig.set_size_inches(11,7)


    plt.xlabel('Downsampling Ratio', size=30)
    plt.xticks(fontsize= 25)
    plt.ylabel('GenomeDISCO', size=30)
    plt.yticks(fontsize= 25)
    plt.legend(fontsize=25)

    plt.savefig('results/figures/downsampled-models_real-world_results_genomedisco.png')
    plt.cla()
    plt.clf()
    plt.close()


def create_line_graph_real_world_datasets_retrained_models(input_path):
    reader = csv.reader(open(input_path, 'r'))
    data = {}
    #x_values = [0,0,0,0,0,0,0]
    for idx, row in enumerate(reader):
        print(idx, row)
        if idx == 0:
            row = list(filter(lambda x: x!= '', row))
            x_values = row
        else:
            method = row[0]
            data[method] = list(map(lambda x: float(x), row[1:]))

    

    plt.plot(x_values,  data['HiCNN-Baseline'], color='#009E73', label='HiCNN-Downsampled', linewidth=4.0, marker='*', markersize=20)
    plt.plot(x_values,  data['HiCNN-LRC-1'], color='#FF5E00', label='HiCNN-LRC-1', linewidth=4.0, marker='X', markersize=20)
    plt.plot(x_values,  data['HiCNN-LRC-3'], color='#C10001', label='HiCNN-LRC-3', linewidth=4.0, marker='<', markersize=20)
    plt.plot(x_values,  data['HiCNN-LRC-4'], color='#000F21', label='HiCNN-LRC-4', linewidth=4.0, marker='>', markersize=20)
    
    fig = plt.gcf()
    fig.tight_layout()
    fig.set_size_inches(11,7)


    plt.xlabel('Downsampling Ratio', size=30)
    plt.xticks(fontsize= 25)
    plt.ylabel('GenomeDISCO', size=30)
    plt.yticks(fontsize= 25)
    plt.legend(fontsize=25)

    plt.savefig('results/figures/retrained-models_real-world_results_genomedisco.png')
    plt.cla()
    plt.clf()
    plt.close()


def create_genome_disco_toe_to_toe_bargraph(data, oname):
    labels = [
        ' ',
        '  '
    ]
    colors = [
        '#009E73',
        '#C10001'
    ]  
    data_averages = []
    for x in data:
        data_averages.append(np.mean(x))

    print(ttest_ind(data[0], data[1]))

    ymin = round(max([0, (round(min(data_averages), 1)-0.2)]), 1)
    ymax = round(min([1.0, (round(max(data_averages), 1)+0.1)]), 1)

    print(ymin, ymax)

    plt.bar(labels, data_averages, color=colors)
    plt.xticks([])
    plt.ylabel('GenomeDISCO', fontsize=30)
    plt.ylim(ymin, ymax)

    fig = plt.gcf()
    fig.tight_layout()
    fig.set_size_inches(7,7)
    fig.savefig('results/figures/{}_genomedisco-bargraph.png'.format(oname))
    plt.cla()
    plt.clf()
